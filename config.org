#+title:Doom-emacs config
* Basic stuff
#+begin_src emacs-lisp :tangle yes
(add-to-list 'load-path "~/.config/doom/elisp")
#+end_src

  Yooooooooooo let's go

#+BEGIN_SRC emacs-lisp :tangle yes
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
(setq user-full-name "Thomas F. K. Jorna"
      user-mail-address "jorna@jtrialerror.com")
#+end_src
** ...
#+begin_src emacs-lisp :tangle yes

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/OneDrive/org-roam/"
      org-roam-directory "~/OneDrive/org-roam")

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;  .
#+end_src
* UI


** Theme
*** Nano

     Basic things you can keep in place without being locked into nano
  #+begin_src emacs-lisp :tangle no
(setq nano-font-family-monospaced "Overpass Mono")
(setq nano-font-family-proportional "Noto Serif")
(setq nano-font-size 13)

        ;(defvar nano-theme-light-var t)
(require 'disp-table)
(require 'nano-theme-dark)
(require 'nano-theme-light)
;(require 'nano-layout)
;(require 'nano-base-colors)
(require 'nano-faces)
(nano-faces)
  #+end_src

  The real fun begins here
  #+begin_src emacs-lisp :tangle no
(require 'nano-theme)
(nano-theme)
(require 'nano-modeline)
;(require 'nano-writer)
;;(nano-theme)
;;
  #+end_src

  Obsolete function due to nano-toggle-face
  #+begin_src emacs-lisp :tangle no

(defun nano-change-theme-dark ()
  (interactive)
  (progn
  (nano-theme-set-dark)
  (nano-faces)
  (nano-theme)))

(defun nano-change-theme-light ()
  (interactive)
  (progn
  (nano-theme-set-light)
  (nano-faces)
  (nano-theme)))

(defun nano-change-theme ()
  (interactive)
  (if nano-theme-light-var (nano-change-theme-dark) (nano-change-theme-light))
  (setq nano-theme-light-var (not nano-theme-light-var)))
  #+end_src

  I always want this, regardless of whether I am uisng nano or not.

  #+begin_src emacs-lisp :tangle yes
(setq default-frame-alist
      (append (list
	       ;; '(font . "Roboto Mono Emacs Regular:size=14")
	       '(min-height . 1)  '(height     . 45)
	       '(min-width  . 1) '(width      . 81)
               '(vertical-scroll-bars . nil)
               '(internal-border-width . 40)
               '(left-fringe    . 0)
               '(right-fringe   . 0)
               '(tool-bar-lines . 0)
               '(menu-bar-lines . 0))))



;  (setq centaur-tabs-style "wave")
;  (setq centaur-tabs-set-bar 'under)
;; Note: If you're not using Spacmeacs, in order for the underline to display
;; correctly you must add the following line:
;(setq x-underline-at-descent-line t)


;;
;;; Packages
  #+end_src
*** Doom
   I'm either using nano or doom-theme, this is the latter
   #+begin_src emacs-lisp :tangle yes
(setq doom-theme 'doom-plain)
   #+end_src

To set the fringes how i want them
#+begin_src emacs-lisp :tangle yes
(add-hook! 'solaire-mode-hook
  ;(set-face-attribute 'solaire-fringe-face nil :background (face-background 'solaire-hl-line-face))
  (set-face-attribute 'fringe nil :background (face-background 'solaire-default-face))
  )
#+end_src

** Fonts

#+begin_src emacs-lisp :tangle yes
(use-package! mixed-pitch
  :hook (org-mode . mixed-pitch-mode)
  :config
  (setq mixed-pitch-face 'variable-pitch))
#+end_src

#+begin_src emacs-lisp :tangle yes
(setq doom-font (font-spec :family "Fira Code" :size 15 :weight 'semi-light)
       doom-variable-pitch-font (font-spec :family "Noto Serif" :style "Regular" :size 18 :weight 'regular))

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You an either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
#+end_src

** Modeline
#+begin_src emacs-lisp :tangle no
(defvar +modeline--old-bar-height nil)
;;;###autoload
(defun +modeline-resize-for-font-h ()
  "Adjust the modeline's height when the font size is changed by
`doom/increase-font-size' or `doom/decrease-font-size'.
Meant for `doom-change-font-size-hook'."
  (unless +modeline--old-bar-height
    (setq +modeline--old-bar-height doom-modeline-height))
  (let ((default-height +modeline--old-bar-height)
        (scale (or (frame-parameter nil 'font-scale) 0)))
    (setq doom-modeline-height
          (if (> scale 0)
              (+ default-height (* scale doom-font-increment))
            default-height))))

;;;###autoload
(defun +modeline-update-env-in-all-windows-h (&rest _)
  "Update version strings in all buffers."
  (dolist (window (window-list))
    (with-selected-window window
      (when (fboundp 'doom-modeline-update-env)
        (doom-modeline-update-env))
      (force-mode-line-update))))

;;;###autoload
(defun +modeline-clear-env-in-all-windows-h (&rest _)
  "Blank out version strings in all buffers."
  (unless (featurep! +light)
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (setq doom-modeline-env--version
              (bound-and-true-p doom-modeline-load-string)))))
  (force-mode-line-update t))

(use-package! doom-modeline
  :hook (after-init . doom-modeline-mode)
  :hook (doom-modeline-mode . size-indication-mode) ; filesize in modeline
  :hook (doom-modeline-mode . column-number-mode)   ; cursor column in modeline
  :init
  (unless after-init-time
    ;; prevent flash of unstyled modeline at startup
    (setq-default mode-line-format nil))
  ;; We display project info in the modeline ourselves
  (setq projectile-dynamic-mode-line nil)
  ;; Set these early so they don't trigger variable watchers
  (setq doom-modeline-bar-width 3
        doom-modeline-github nil
        doom-modeline-mu4e nil
        doom-modeline-persp-name nil
        doom-modeline-minor-modes nil
        doom-modeline-major-mode-icon nil
        doom-modeline-buffer-file-name-style 'relative-from-project
        ;; Only show file encoding if it's non-UTF-8 and different line endings
        ;; than the current OSes preference
        doom-modeline-buffer-encoding 'nondefault
        doom-modeline-default-eol-type
        (cond (IS-MAC 2)
              (IS-WINDOWS 1)
              (0)))

  ;; Fix modeline icons in daemon-spawned graphical frames. We have our own
  ;; mechanism for disabling all-the-icons, so we don't need doom-modeline to do
  ;; it for us. However, this may cause unwanted padding in the modeline in
  ;; daemon-spawned terminal frames. If it bothers you, you may prefer
  ;; `doom-modeline-icon' set to `nil'.
  (when (daemonp)
    (setq doom-modeline-icon t))
  :config
  ;; HACK Fix #4102 due to empty all-the-icons return value (caused by
  ;;      `doom--disable-all-the-icons-in-tty-a' advice) in tty daemon frames.
  (defadvice! +modeline-disable-icon-in-daemon-a (orig-fn &rest args)
    :around #'doom-modeline-propertize-icon
    (when (display-graphic-p)
      (apply orig-fn args)))

  ;; Fix an issue where these two variables aren't defined in TTY Emacs on MacOS
  (defvar mouse-wheel-down-event nil)
  (defvar mouse-wheel-up-event nil)

  (add-hook 'after-setting-font-hook #'+modeline-resize-for-font-h)
  (add-hook 'doom-load-theme-hook #'doom-modeline-refresh-bars)

  (add-hook '+doom-dashboard-mode-hook #'doom-modeline-set-project-modeline)

  (add-hook! 'magit-mode-hook
    (defun +modeline-hide-in-non-status-buffer-h ()
      "Show minimal modeline in magit-status buffer, no modeline elsewhere."
      (if (eq major-mode 'magit-status-mode)
          (doom-modeline-set-vcs-modeline)
        (hide-mode-line-mode))))

  ;; Some functions modify the buffer, causing the modeline to show a false
  ;; modified state, so force them to behave.
  (defadvice! +modeline--inhibit-modification-hooks-a (orig-fn &rest args)
    :around #'ws-butler-after-save
    (with-silent-modifications (apply orig-fn args))))
#+end_src

#+begin_src emacs-lisp :tangle no
(defun doom-modeline--set-char-widths (alist)
  "Set correct widths of icons characters in ALIST."
  (while (char-table-parent char-width-table)
    (setq char-width-table (char-table-parent char-width-table)))
  (dolist (pair alist)
    (let ((width 1)
          (chars (cdr pair))
          (table (make-char-table nil)))
      (dolist (char chars)
        (set-char-table-range table char width))
      (optimize-char-table table)
      (set-char-table-parent table char-width-table)
      (setq char-width-table table))))

#+end_src
*** Doom-modeline settings

#+begin_src elisp :tangle yes
(after! doom-modeline
  (setq doom-modeline-enable-word-count t
        doom-modeline-header-line nil
        ;doom-modeline-hud nil
        doom-themes-padded-modeline t
        doom-flatwhite-brighter-modeline nil
        doom-plain-brighter-modeline nil))
(add-hook! 'doom-modeline-mode-hook
           (progn
  (set-face-attribute 'header-line nil
                      :background (face-background 'mode-line)
                      :foreground (face-foreground 'mode-line))
  ))
#+end_src

Trying to make my own thing work
#+begin_src emacs-lisp :tangle yes
(after! doom-modeline
  (doom-modeline-def-modeline 'main
    '(bar matches buffer-info vcs word-count)
    '(buffer-position misc-info major-mode "                  "))
  (custom-set-faces! '(mode-line :family "Fira Code"))
  (doom-modeline--set-char-widths doom-modeline-rhs-icons-alist))

#+end_src

*** Mlscroll

    Very cool indicator of where you are in the buffer. Works not that well with `doom-modeline` though.

#+begin_src emacs-lisp :tangle no
(use-package! mlscroll
  :preface
  ;(setq mlscroll-mode-line-font-width 9)
  :init
  (message "Init mode line %s" 'mode-line)
  (setq mlscroll-right-align nil)
  (add-to-list 'mode-line-misc-info '(:eval (mlscroll-mode-line)) 'append)
  (setq mlscroll-width-chars 15)
  (setq mlscroll-border 6)
  (setq mlscroll-in-color "#555555")
  ;(setq mlscroll-mode-line-font-width 9)
  :config
  (mlscroll-mode 1)
  ;(setq mlscroll-mode-line-font-with 9)
  )
#+end_src



** Startup

   #+begin_src emacs-lisp :tangle no
(use-package! dashboard
  :init
  (dashboard-setup-startup-hook)
  ;(setq initial-buffer-choice
  ;      (lambda () (get-buffer "*dashboard*")))
  :config
  (setq dashboard-center-content t
        dashboard-banner-logo-title "Emacs"
        dashboard-startup-banner 'logo
        dashboard-set-file-icons t
        dashboard-set-heading-icons t
        dashboard-set-init-info t
        dashboard-week-agenda t
        ))
   #+end_src
** Cursor
#+begin_src emacs-lisp :tangle no
;(after! org
;  (require 'pulse-cursor))
;
;(add-hook! 'org-mode-hook (pulse-cursor-mode))


(require 'pulse)

(defface pulse-cursor-overlay-face1
  '((((class color) (background light))
     :background (face-background 'default))
    (((class color) (background dark))
     :background (face-background 'default)))
  "")

(defvar pulse-cursor-idle-timer nil
  "Timer started after `pulse-cursor-delay' seconds of Emacs idle time.
The function `pulse-cursor-start' is called when the timer fires.")

(defvar pulse-cursor-timer nil
  "Timer started from `pulse-cursor-start'.
This timer calls `pulse-cursor-timer-function' every
`pulse-cursor-interval' seconds.")

(defgroup pulse-cursor nil
  "Displaying text cursors."
  :version "21.1"
  :group 'frames)

(defcustom pulse-cursor-delay 0.5
  "Seconds of idle time before the first blink of the cursor.
Values smaller than 0.2 sec are treated as 0.2 sec."
  :type 'number
  :group 'pulse-cursor
  :set (lambda (symbol value)
         (set-default symbol value)
         (when pulse-cursor-idle-timer (pulse-cursor--start-idle-timer))))

(defcustom pulse-cursor-interval 0.5
  "Length of cursor blink interval in seconds."
  :type 'number
  :group 'pulse-cursor
  :set (lambda (symbol value)
         (set-default symbol value)
         (when pulse-cursor-timer (pulse-cursor--start-timer))))

(defcustom pulse-cursor-blinks 10
  "How many times to blink before using a solid cursor on NS, X, and MS-Windows.
Use 0 or negative value to blink forever."
  :version "24.4"
  :type 'integer
  :group 'pulse-cursor)

(defvar pulse-cursor-blinks-done 1
  "Number of blinks done since we started blinking on NS, X, and MS-Windows.")

(defun pulse-cursor--start-idle-timer ()
  "Start the `pulse-cursor-idle-timer'."
  (when pulse-cursor-idle-timer (cancel-timer pulse-cursor-idle-timer))
  (setq pulse-cursor-idle-timer
        ;; The 0.2 sec limitation from below is to avoid erratic
        ;; behavior (or downright failure to display the cursor
        ;; during command execution) if they set pulse-cursor-delay
        ;; to a very small or even zero value.
        (run-with-idle-timer (max 0.2 pulse-cursor-delay)
                             :repeat #'pulse-cursor-start)))

(defun pulse-cursor--start-timer ()
  "Start the `pulse-cursor-timer'."
  (when pulse-cursor-timer (cancel-timer pulse-cursor-timer))
  (setq pulse-cursor-timer
        (run-with-timer pulse-cursor-interval pulse-cursor-interval
                        #'pulse-cursor-timer-function)))

(defun pulse-cursor-start ()
  "Timer function called from the timer `pulse-cursor-idle-timer'.
This starts the timer `pulse-cursor-timer', which makes the cursor blink
if appropriate.  It also arranges to cancel that timer when the next
command starts, by installing a pre-command hook."
  (when (null pulse-cursor-timer)
    ;; Set up the timer first, so that if this signals an error,
    ;; pulse-cursor-end is not added to pre-command-hook.
    (setq pulse-cursor-blinks-done 1)
    (pulse-cursor--start-timer)
    (add-hook 'pre-command-hook 'pulse-cursor-end)
    (internal-show-cursor nil nil)
    ))

(defun pulse-cursor-timer-function ()
  "Timer function of timer `pulse-cursor-timer'."

  (internal-show-cursor nil (not (internal-show-cursor-p)))

  (pulse-momentary-highlight-region (point) (+ 1 (point)) 'pulse-cursor-overlay-face1)
  ;;(pulse-momentary-highlight-region (point-min) (point-max))

  ;; Suspend counting blinks when the w32 menu-bar menu is displayed,
  ;; since otherwise menu tooltips will behave erratically.
  (or (and (fboundp 'w32--menu-bar-in-use)
	   (w32--menu-bar-in-use))
      (setq pulse-cursor-blinks-done (1+ pulse-cursor-blinks-done)))
  ;; Each blink is two calls to this function.
  (when (and (> pulse-cursor-blinks 0)
             (<= (* 2 pulse-cursor-blinks) pulse-cursor-blinks-done))
    (pulse-cursor-suspend)
    (add-hook 'post-command-hook 'pulse-cursor-check)))

(defun pulse-cursor-end ()
  "Stop cursor blinking.
This is installed as a pre-command hook by `pulse-cursor-start'.
When run, it cancels the timer `pulse-cursor-timer' and removes
itself as a pre-command hook."
  (remove-hook 'pre-command-hook 'pulse-cursor-end)

  (internal-show-cursor nil t)

  (when pulse-cursor-timer
    (cancel-timer pulse-cursor-timer)
    (setq pulse-cursor-timer nil)))

(defun pulse-cursor-suspend ()
  "Suspend cursor blinking.
This is called when no frame has focus and timers can be suspended.
Timers are restarted by `pulse-cursor-check', which is called when a
frame receives focus."
  (pulse-cursor-end)
  (when pulse-cursor-idle-timer
    (cancel-timer pulse-cursor-idle-timer)
    (setq pulse-cursor-idle-timer nil)))

(defun pulse-cursor--should-blink ()
  "Determine whether we should be blinking.
Returns whether we have any focused non-TTY frame."
  (and pulse-cursor-mode
       (let ((frame-list (frame-list))
             (any-graphical-focused nil))
         (while frame-list
           (let ((frame (pop frame-list)))
             (when (and (display-graphic-p frame) (frame-focus-state frame))
               (setf any-graphical-focused t)
               (setf frame-list nil))))
         any-graphical-focused)))

(defun pulse-cursor-check ()
  "Check if cursor blinking shall be restarted.
This is done when a frame gets focus.  Blink timers may be
stopped by `pulse-cursor-suspend'.  Internally calls
`pulse-cursor--should-blink' and returns its result."
  (let ((should-blink (pulse-cursor--should-blink)))
    (when (and should-blink (not pulse-cursor-idle-timer))
      (remove-hook 'post-command-hook 'pulse-cursor-check)
      (pulse-cursor--start-idle-timer))
    should-blink))

(defun pulse-cursor--rescan-frames (&optional _ign)
  "Called when the set of focused frames changes or when we delete a frame."
  (unless (pulse-cursor-check)
    (pulse-cursor-suspend)))

(define-minor-mode pulse-cursor-mode
  "Toggle cursor blinking (Blink Cursor mode).
If the value of `pulse-cursor-blinks' is positive (10 by default),
the cursor stops blinking after that number of blinks, if Emacs
gets no input during that time.
See also `pulse-cursor-interval' and `pulse-cursor-delay'.
This command is effective only on graphical frames.  On text-only
terminals, cursor blinking is controlled by the terminal."
  :init-value  (not (or noninteractive
		       no-blinking-cursor
		       (eq system-type 'ms-dos)
		       (not (display-blink-cursor-p))))
  ;:initialize 'custom-initialize-delay
  :group 'pulse-cursor
  :global t
  (pulse-cursor-suspend)
  (remove-hook 'after-delete-frame-functions #'pulse-cursor--rescan-frames)
  (remove-function after-focus-change-function #'pulse-cursor--rescan-frames)
  (when pulse-cursor-mode
    (add-function :after after-focus-change-function #'pulse-cursor--rescan-frames)
    (add-hook 'after-delete-frame-functions #'pulse-cursor--rescan-frames)
    (pulse-cursor--start-idle-timer)))

(setq blink-cursor-alist '((box . nil)))
(setq pulse-cursor-interval 0.5)
(setq pulse-cursor-blinks 0)
(setq pulse-delay 0.015)
(setq pulse-iterations 20)
;(pulse-cursor-mode +1)
(when nil
  (pulse-cursor-mode +1)
  (pulse-cursor-mode -1)
  (blink-cursor-mode +1)
  (blink-cursor-mode -1)

  (internal-show-cursor nil t)
  (internal-show-cursor nil nil)

  (blink-cursor-mode +1)
  (setq blink-cursor-alist '((box . hollow)))
  (setq blink-cursor-interval 0.25)
  (setq blink-cursor-blinks 0)
  )
#+end_src

#+begin_src emacs-lisp :tangle yes
(setq blink-cursor-alist '((box . box)))
(setq blinking-cursor-mode 1)
#+end_src
* Org-Mode customization


Allows you to jump in and out of latex fragments without using `C-c C-x C-l` all the time, beautiful.
#+begin_src emacs-lisp :tangle yes
(use-package! org-fragtog
  :after org
  :hook (org-mode . org-fragtog-mode)
  )

#+end_src

Org-fragtog for everything else.
#+begin_src emacs-lisp :tangle yes
(use-package! org-appear
  :after org
  :hook (org-mode . org-appear-mode)
  :config (setq
           org-appear-autolinks t
           org-appear-autoentities t
           org-appear-autosubmarkers t ))


#+end_src

Buggy yet beautiful transclusion of org-content from another file in the current buffer. Very cool that this is possible, but I don't use it consistently as the "code" is kind of a bitch to write and gets rid of org-roam links.
#+begin_src emacs-lisp :tangle yes
(use-package! org-transclusion
  :after org-roam
  )
#+end_src

Having zero-width spaces can be very useful /sometimes/â€‹!
#+begin_src emacs-lisp :tangle yes

(map! :map org-mode-map
:nie "C-M-SPC" (cmd! (insert "\u200B")))
#+end_src
#+begin_src emacs-lisp :tangle yes
(alert "AAA" :style 'message)
#+end_src

** Org-roam
#+begin_src emacs-lisp :tangle yes
        (defvar +org-roam-open-buffer-on-find-file nil
  "If non-nil, open the org-roam buffer when opening an org roam file.")
(use-package! org-roam
  ;;:hook (org-load . org-roam-mode)
  :hook (org-roam-backlinks-mode . turn-on-visual-line-mode)
  :commands (org-roam-buffer-toggle-display
             org-roam-dailies-find-date
             org-roam-dailies-find-today
             org-roam-dailies-find-tomorrow
             org-roam-dailies-find-yesterday)
  :preface
  ;; Set this to nil so we can later detect if the user has set custom values
  ;; for these variables. If not, default values will be set in the :config
  ;; section.
  (defvar org-roam-directory nil)
  (defvar org-roam-db-location nil)
  :init
  (map! :after org
        :map org-mode-map
        :localleader
        :prefix ("m" . "org-roam")
        "b" #'org-roam-switch-to-buffer
        "f" #'org-roam-find-file
        "g" #'org-roam-graph
        "i" #'org-roam-insert
        "I" #'org-roam-insert-immediate
        "m" #'org-roam
        "t" #'org-roam-tag-add
        "T" #'org-roam-tag-delete
        (:prefix ("d" . "by date")
         :desc "Find previous note" "b" #'org-roam-dailies-find-previous-note
         :desc "Find date"          "d" #'org-roam-dailies-find-date
         :desc "Find next note"     "f" #'org-roam-dailies-find-next-note
         :desc "Find tomorrow"      "m" #'org-roam-dailies-find-tomorrow
         :desc "Capture today"      "n" #'org-roam-dailies-capture-today
         :desc "Find today"         "t" #'org-roam-dailies-find-today
         :desc "Capture Date"       "v" #'org-roam-dailies-capture-date
         :desc "Find yesterday"     "y" #'org-roam-dailies-find-yesterday
         :desc "Find directory"     "." #'org-roam-dailies-find-directory))
  :config
  (setq org-roam-directory
        (file-name-as-directory
         (file-truename
          (expand-file-name (or org-roam-directory "roam")
                            org-directory)))
        org-roam-db-location (or org-roam-db-location
                                 (concat doom-etc-dir "org-roam.db"))
        org-roam-verbose nil   ; https://youtu.be/fn4jIlFwuLU
        ;; Make org-roam buffer sticky; i.e. don't replace it when opening a
        ;; file with an *-other-window command.
        org-roam-buffer-window-parameters '((no-delete-other-windows . t))
        org-roam-completion-everywhere t
        org-roam-completion-system
        (cond ((featurep! :completion helm) 'helm)
              ((featurep! :completion ivy) 'ivy)
              ((featurep! :completion ido) 'ido)
              ('default)))

  ;; Normally, the org-roam buffer doesn't open until you explicitly call
  ;; `org-roam'. If `+org-roam-open-buffer-on-find-file' is non-nil, the
  ;; org-roam buffer will be opened for you when you use `org-roam-find-file'
  ;; (but not `find-file', to limit the scope of this behavior).
  (add-hook! 'find-file-hook
    (defun +org-roam-open-buffer-maybe-h ()
      (and +org-roam-open-buffer-on-find-file
           (memq 'org-roam-buffer--update-maybe post-command-hook)
           (not (window-parameter nil 'window-side)) ; don't proc for popups
           (not (eq 'visible (org-roam-buffer--visibility)))
           (with-current-buffer (window-buffer)
             (org-roam-buffer--get-create)))))

  ;; Hide the mode line in the org-roam buffer, since it serves no purpose. This
  ;; makes it easier to distinguish from other org buffers.
  (add-hook 'org-roam-buffer-prepare-hook #'hide-mode-line-mode))

#+end_src

*** Org-roam-capture templates

#+begin_src emacs-lisp :tangle yes
(after! org-roam
    (setq org-roam-capture-templates
          `(("s" "standard" plain (function org-roam--capture-get-point)
     "%?"
     :file-name "%<%Y%m%d%H%M%S>-${slug}"
     :head "#+title: ${title}\n#+roam_tags: \n\n* ${title}\n\n"
     :unnarrowed t)
        ("d" "definition" plain (function org-roam--capture-get-point)
         "%?"
         :file-name "${slug}"
         :head "#+title: ${title}\n#+roam_tags: definition \n\n* ${title}\n\n\n* Examples\n"
         :unnarrowed t)))
  )

#+end_src

*** Server
**** Protocol
#+begin_src emacs-lisp :tangle yes

;; Since the org module lazy loads org-protocol (waits until an org URL is
;; detected), we can safely chain `org-roam-protocol' to it.
(use-package! org-roam-protocol
  :after org-protocol)
#+end_src

**** Actual server
#+begin_src emacs-lisp :tangle yes

(use-package! org-roam-server
  :after org-roam
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8081
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20
        org-roam-server-network-vis-options "{\"physics\": {\"stabilization\": {\"iterations\": 100}}}"
        ;i;"{\"physics\": {\"enabled\": true, \"barnesHut\":{\"gravitationalConstant\" : -6000, \"avoidOverlap\" : 0.5, \"springLength\" : 200}, \"stabilization\": {\"enabled\": true, \"iterations\": 30}},
        ;;\"edges\": {\"physics\": true, \"hidden\": false, \"smooth\": {\"enabled\": false, \"type\": \"continuous\"}}}"
        org-roam-server-cite-edge-dashes nil
        org-roam-server-extra-cite-edge-options (list (cons 'width 3))
        ))
#+end_src

Org-roam server does not really work well with with `smart-parens` for some reason, this fixes that.
#+begin_src emacs-lisp :tangle yes
(defun org-roam-server-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (smartparens-global-mode -1)
    (org-roam-server-mode 1)
    (browse-url-xdg-open (format "http://localhost:%d" org-roam-server-port))
    (smartparens-global-mode 1))

;; automatically enable server-mode
(after! org-roam
  (smartparens-global-mode -1)
  (org-roam-server-mode)
  (smartparens-global-mode 1))
#+end_src

*** Citations
#+begin_src emacs-lisp :tangle yes
(use-package! org-ref
    ;:after org-roam
    :config
    (setq
         org-ref-completion-library 'org-ref-ivy-cite
         org-ref-get-pdf-filename-function 'org-ref-get-pdf-filename-helm-bibtex
         org-ref-default-bibliography (list "/home/thomas/OneDrive/org-roam/bib/Library.bib")
         org-ref-bibliography-notes "/home/thomas/OneDrive/org-roam/bibnotes.org"
         org-ref-note-title-format "* %y - %t\n :PROPERTIES:\n  :Custom_ID: %k\n  :NOTER_DOCUMENT: %F\n :ROAM_KEY: cite:%k\n  :AUTHOR: %9a\n  :JOURNAL: %j\n  :YEAR: %y\n  :VOLUME: %v\n  :PAGES: %p\n  :DOI: %D\n  :URL: %U\n :END:\n\n"
         org-ref-notes-directory "/home/thomas/OneDrive/org-roam/"
         org-ref-notes-function 'orb-edit-notes
    ))

(after! org-ref
(setq
 bibtex-completion-notes-path "/home/thomas/OneDrive/org-roam/"
 bibtex-completion-bibliography "/home/thomas/OneDrive/org-roam/bib/Library.bib"
 bibtex-completion-pdf-field "file"
 bibtex-completion-notes-template-multiple-files
 (concat
  "#+TITLE: ${title}\n"
  "#+ROAM_KEY: cite:${=key=}\n"
  "* TODO Notes\n"
  ":PROPERTIES:\n"
  ":Custom_ID: ${=key=}\n"
  ":NOTER_DOCUMENT: %(orb-process-file-field \"${=key=}\")\n"
  ":AUTHOR: ${author-abbrev}\n"
  ":JOURNAL: ${journaltitle}\n"
  ":DATE: ${date}\n"
  ":YEAR: ${year}\n"
  ":DOI: ${doi}\n"
  ":URL: ${url}\n"
  ":END:\n\n"
  )
 )
)

#+end_src

Company-org-roam seemed like a good idea, but I never use it.

#+begin_src emacs-lisp :tangle no
        (use-package! company-org-roam
  :after org-roam
  :config
  (set-company-backend! 'org-mode '(company-org-roam company-yasnippet company-dabbrev)))
#+end_src

ORB
#+begin_src emacs-lisp :tangle yes

(use-package! org-roam-bibtex
  :after org-roam
  :hook (org-roam-mode . org-roam-bibtex-mode)
  :config
  (require 'org-ref)
  (setq orb-preformat-keywords
   '("citekey" "title" "url" "file" "author-or-editor" "keywords" "pdf" "doi" "author" "tags"))
  (setq orb-templates
        '(("r" "ref" plain (function org-roam-capture--get-point)
           ""
           :file-name "${slug}"
           :head "#+TITLE: ${citekey}: ${title}\n#+ROAM_KEY: ${ref}
\n#+ROAM_TAGS: reference ${keywords} \n
\n* ${title}\n  :PROPERTIES:\n  :Custom_ID: ${citekey}\n  :DOI: ${doi}\n  :AUTHOR: ${author}\n  :END:\n\n
\n* Summary
\n\n\n* Rough note space\n"
           :unnarrowed t))))
;)
#+end_src
** To do things with pdfs with

   Don't really use this anymore since zotero got a pdf reader
#+begin_src emacs-lisp :tangle yes
   (use-package! org-noter
  :after (:any org pdf-view)
  :config
  (setq
   ;; The WM can handle splits
   ;;org-noter-notes-window-location 'other-frame
   ;; Please stop opening frames
   ;;org-noter-always-create-frame nil
   ;; I want to see the whole file
   org-noter-hide-other nil
   ;; Everything is relative to the rclone mega
   org-noter-notes-search-path "/home/thomas/OneDrive/org-roam"
   )
  )


(use-package! org-pdftools
  :hook (org-load . org-pdftools-setup-link))
(use-package! org-noter-pdftools
  :after org-noter
  :config
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))


#+end_src

nroam puts the org-roam buffer on the bottom, much more natural and less obstrustive, but not does cause some problems.
#+begin_src emacs-lisp :tangle yes
        (use-package! nroam
  :after org-roam
  :config
  (add-hook 'org-roam-mode-hook  #'nroam-setup-maybe)
)


#+end_src

*** Org-ol

    Outliners on the side, neat.

#+begin_src emacs-lisp :tangle yes
(use-package! org-ol-tree
  :after org
  :commands org-ol-tree
  :hook (org-ol-tree-mode . visual-line-mode)
  :config
  (setq org-ol-tree-ui-window-auto-resize nil
        org-ol-tree-ui-window-max-width 0.3
        org-ol-tree-ui-window-position 'left))
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Outline" "O" #'org-ol-tree)
#+end_src
** Hooks

*** Hook to get rid of stars

You know what I hate? Organized lists.
No but when I'm writing I don't want org's usual indentation and stars and all that bullshit, I want it to look like a wordprocessor, so no stars!

#+begin_src emacs-lisp :tangle yes
(defun org-mode-remove-stars ()
  (font-lock-add-keywords
   nil
   '(("^\\*+ "
      (0
       (prog1 nil
         (put-text-property (match-beginning 0) (match-end 0)
                            'invisible t)))))))

(add-hook! 'org-mode-hook #'org-mode-remove-stars)
#+end_src

*** Yeah I don't know where to put this
#+begin_src emacs-lisp :tangle yes
  ;; hide title / author ... keywords

;;; Ugly org hooks
(defun nicer-org ()
  (progn
  (+org-pretty-mode 1)
  (mixed-pitch-mode 1)
  (hl-line-mode -1)
  (display-line-numbers-mode -1)
  (olivetti-mode 1)
  (org-num-mode 1)
  (org-superstar-mode -1)
  ;(org-indent-mode -1)
  ))

(add-hook! 'org-mode-hook  #'nicer-org)

#+end_src

*** Org variables

#+begin_src emacs-lisp :tangle yes


(after! org
  (setq org-startup-with-latex-preview 1 ;always preview latex
        org-startup-with-inline-images 1 ;always preview images
        ;org-hide-leading-stars 1
        org-startup-indented nil         ; don't indent
        ;org-superstar-headline-bullets-list`("\u200b")
  ;      org-startup-folded nil
        ;org-startup-numerated 1         ; does not seem to work
        org-hidden-keywords '(title author date startup roam_tags)
        org-pretty-entities 1            ; show unicode characters
        org-num-max-level 3              ; no 1.1.1.2
        ;header-line-format nil
        ;; Open indirect buffer in another window rather than this one
        org-indirect-buffer-display 'other-window
        ))


#+end_src

**** Better indirect buffers
Sometimes I want to move a tree to an indirect buffer, but sometimes I want to put it in another window, sometimes the same one, and sometimes to another frame. By default there are no functions for this but are controlled by ~org-indirect-buffer-display~. This is a hacky way of achieving this
#+begin_src emacs-lisp :tangle yes
(defun +org-tree-to-indirect-buffer-options (option)
    (let* ((old-value org-indirect-buffer-display))
          (progn
            (setq org-indirect-buffer-display option)
          (org-tree-to-indirect-buffer)
          (setq org-indirect-buffer-display old-value))))

(defun +org-tree-to-indirect-other-window ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'other-window))

(defun +org-tree-to-indirect-current-window ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'current-window))

(defun +org-tree-to-indirect-dedicated-frame ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'dedicated-frame))
#+end_src
*** Custom faces

A lil bigger. No a lil smaller. Peeerrrfect.
#+begin_src emacs-lisp :tangle yes
(after! org
(custom-set-faces!
  '((org-block) :background nil)
  )
  (defface redd
    '((((class color) (min-colors 88) (background light))
      :foreground "red"))
    "Red."
    :group 'basic-faces)
  (custom-set-faces!
    ;'(org-document-title :height 1.6 :weight bold)
    '(org-level-1 :height 1.3 :weight extrabold :slant normal)
    '(org-level-2 :height 1.2 :weight bold :slant normal)
    '(org-level-3 :height 1.1 :weight regular :slant normal)
    ;'(org-document-info  :inherit 'nano-face-faded)
    '(org-document-title   ;:foreground ,(doom-color 'black)
                           :family "Noto Serif"
                           :height 250
                           :weight medium)))
#+end_src
*** emphsis faces

I want to be able to do some kind of cruse highlighting, so = becomes =red=.
#+begin_src emacs-lisp :tangle yes
(after! org
(setq org-emphasis-alist
        '(("*" (bold))
          ("/" italic)
          ("_" underline)
          ("=" redd)
          ("~" code)
          ("+" (:strike-through t)))))
#+end_src

Ideally I would be able to add my own custom bullshit in here, but I don't know how to do that.

*** Ligatures

    Yns make them pretty
#+begin_src emacs-lisp :tangle yes
        (after! org
(setq org-ellipsis " â–¾ ")
  (appendq! +ligatures-extra-symbols
          `(:checkbox      "â˜"
            :pending       "â—¼"
            :checkedbox    "â˜‘"
            :list_property "âˆ·"
            :em_dash       "â€”"
            :ellipses      "â€¦"
            :arrow_right   "â†’"
            :arrow_left    "â†"
            :title         nil
            :subtitle      "ð™©"
            :author        "ð˜¼"
            :date          "ð˜¿"
            :property      "â˜¸"
            :options       "âŒ¥"
            :startup       "â»"
            :macro         "ð“œ"
            :html_head     "ðŸ…·"
            :html          "ðŸ…—"
            :latex_class   "ðŸ„»"
            :latex_header  "ðŸ…»"
            :beamer_header "ðŸ…‘"
            :latex         "ðŸ…›"
            :attr_latex    "ðŸ„›"
            :attr_html     "ðŸ„—"
            :attr_org      "â’ª"
            :begin_quote   "â"
            :end_quote     "âž"
            :caption       "â˜°"
            :header        "â€º"
            :results       "ðŸ ¶"
            :begin_export  "â©"
            :end_export    "âª"
            :properties    "âš™"
            :end           "âˆŽ"
            :priority_a   ,(propertize "âš‘" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "â¬†" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "â– " 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "â¬‡" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "â“" 'face 'all-the-icons-blue)
            :roam_tags ""))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]"
  :roam_tags     "#+roam_tags:")
(plist-put +ligatures-extra-symbols :name "â")
)

(with-eval-after-load 'org
  (plist-put org-format-latex-options :background 'default))

#+end_src

** Getting Things Done

   Oh yeah this is definitely working for me I've definitely changed as a person.
*** GTD package
    It's pretty good, but it doesn't do my organizing for me sadly.
  #+begin_src emacs-lisp :tangle yes
(use-package! org-gtd
  :after org
  :config
  ;; where org-gtd will put its files. This value is also the default one.
  (setq org-gtd-directory "~/OneDrive/org-roam/")
  ;; package: https://github.com/Malabarba/org-agenda-property
  ;; this is so you can see who an item was delegated to in the agenda
  (setq org-agenda-property-list '("DELEGATED_TO"))
  ;; I think this makes the agenda easier to read
  (setq org-agenda-property-position 'next-line)
  ;; package: https://www.nongnu.org/org-edna-el/
  ;; org-edna is used to make sure that when a project task gets DONE,
  ;; the next TODO is automatically changed to NEXT.
  (setq org-edna-use-inheritance t)
  (org-edna-load)
  :bind
  (("C-c d c" . org-gtd-capture) ;; add item to inbox
  ("C-c d a" . org-agenda-list) ;; see what's on your plate today
  ("C-c d p" . org-gtd-process-inbox) ;; process entire inbox
  ("C-c d n" . org-gtd-show-all-next) ;; see all NEXT items
  ("C-c d s" . org-gtd-show-stuck-projects)) ;; see projects that don't have a NEXT item
  :init
  (bind-key "C-c c" 'org-gtd-clarify-finalize)) ;; the keybinding to hit when you're done editing an item in the processing phase
#+end_src

*** Set agenda files
Because you can't trust ~custom.el~
#+begin_src emacs-lisp :tangle yes

(setq org-agenda-files '("~/OneDrive/org-roam/inbox" "~/OneDrive/org-roam/actionable.org"
                         "~/OneDrive/org-roam/agenda.org" "~/OneDrive/org-roam/incubate.org"
                         "~/OneDrive/org-roam/openquestions.org"))
#+end_src

*** Org capture Templates

Set some capture templates, which I rarely use tbrqhwy
#+begin_src emacs-lisp :tangle yes
(after! org
(setq org-capture-templates `(("i" "Inbox"
                                 entry (file "~/OneDrive/org-roam/inbox.org")
                                 "* %?\n%U\n\n  %i"
                                 :kill-buffer t)
                                ("l" "Todo with link"
                                 entry (file "~/OneDrive/org-rom/inbox.org")
                                 "* %?\n%U\n\n  %i\n  %a"
                                 :kill-buffer t)
                                ("m" "Meeting"
                                 entry (file+headline "/home/thomas/OneDrive/org-roam/agenda.org" "Future")
                                ,(concat "* TODO %? :meeting:\n" "<%<%Y-%m-%d %a %H:00>>"))
                                ("o" "Open Question Thesis"
                                 entry (file+headline "~/OneDrive/org-roam/openquestions.org" "Questions")
                                 "* OPEN %? \n %U\n")))
(set-face-attribute 'org-headline-done nil :strike-through t)
)
#+end_src
*** Org-super agenda

Why yes, I also copied this one example from the ~org-super-agenda~ github, how could you tell?

This does not work nearly as well as I would like it to, like, utility wise. Way too long, way too much information, bubububuh. I want more of a calendar than an agenda I think.
 #+begin_src emacs-lisp :tangle yes
(use-package! org-super-agenda
  :hook (org-agenda-mode . org-super-agenda-mode)
)


  (setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-include-diary t
      org-agenda-block-separator nil
      org-agenda-compact-blocks t
      org-agenda-start-with-log-mode t
      org-agenda-start-day nil)
(setq org-agenda-custom-commands
      '(("d" "Get Things DONE"
         ((agenda "" ((org-agenda-span 1)
                      (org-super-agenda-groups
                       '((:name "Today"
                                :time-grid t
                                :date nil
                                :todo "TODAY"
                                :scheduled nil
                                :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:discard (:todo "TODO"))
                          (:name "Important"
                                 :tag "Important"
                                 :priority "A"
                                 :order 1)
                          (:name "Due Today"
                                 :deadline today
                                 :order 2)
                          (:name "Due Soon"
                                 :deadline future
                                 :order 8)
                          (:name "Overdue"
                                 :deadline past
                                 :order 7)
                          (:name "Thesis"
                                 :tag "thesis"
                                 :order 10)
                          (:name "ESN"
                                 :tag "esn"
                                 :order 12)
                          (:name "JOTE"
                                 :tag "jote"
                                 :order 13)
                          (:name "Emacs"
                                 :tag "emacs"
                                 :order 14)
                          (:name "Home"
                                 :tag "home"
                                 :order 30)
                          (:name "Waiting"
                                 :todo "WAITING"
                                 :order 20)
                          (:name "Notes"
                                 :tag "notes"
                                 :order 20)
                          ;(:name "Open Questions"
                          ;       :todo "OPEN"
                          ;       :order 3)
                          (:name "trivial"
                                 :priority<= "C"
                                 :tag ("Trivial" "Unimportant")
                                 :todo ("SOMEDAY" )
                                 :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))))

 #+end_src

*** Notifications

I want notifications to work so bad but it just isn't working :(
Seems like ~alert~ is not working, should fix that at some point.
#+begin_src emacs-lisp :tangle no
(use-package! org-notifications
  :init (org-notifications-start) )
#+end_src

** Nice writing environment for big babies
Nice big border with the color of the fringe
#+begin_src emacs-lisp :tangle yes
(setq default-frame-alist
      (append (list
	       ;; '(font . "Roboto Mono Emacs Regular:size=14")
	       '(min-height . 1)  '(height     . 45)
	       '(min-width  . 1) '(width      . 81)
               '(vertical-scroll-bars . nil)
               '(internal-border-width . 40)
               '(left-fringe    . 0)
               '(right-fringe   . 0)
               '(tool-bar-lines . 0)
               '(menu-bar-lines . 0))))

(add-hook! 'solaire-mode-hook (set-face-background 'internal-border (face-background 'fringe)))

(set-frame-parameter nil 'internal-border-width 60)
#+end_src

*** Paper-like header/mode-line
Lil' minor mode which gives you a nice distraction free header and footer. At the moment its automatically enabled in org-mode, but I would like it to only be enabled in "writing" buffers, not sure how to implement that yet though.

#+begin_src emacs-lisp :tangle yes
(defvar writing-header--default-format header-line-format
  "Storage for the default `mode-line-format'.
So it can be restored when 'writer-header-line-mode' is disabled.")

(defvar writing-modeline--default-format mode-line-format)

(define-minor-mode writing-header-line-mode
  "Adds a bar with the same color as the fringe as the header-line.
Imitates the look of wordprocessors a bit."
  :init-value nil
  :global nil
  (if writing-header-line-mode
      (progn
      (setq header-line-format
            (concat
             (propertize " " 'display (list 'space :width 'left-fringe) 'face 'fringe)
             (propertize " " 'display (list 'space :width 'left-margin) 'face (list (list :height 400) 'default))
             (propertize " " 'display (list 'space :width 'text) 'face (list (list :height 400) 'default))
             ;(propertize (format " %dW" (count-words (point-min) (point-max))) 'face 'default)
             (propertize " " 'display (list 'space :width 'left-margin) 'face (list (list :height 400) 'default))
    ;;(propertize (format " %dW" (count-words (point-min) (point-max))) 'face 'fringe)
   ;; '("" mode-line-misc-info)
             (propertize " " 'display (list 'space :width 'left-fringe) 'face 'fringe))) ;
        (setq mode-line-format header-line-format))
    (setq header-line-format writing-header--default-format
          mode-line-format writing-modeline--default-format)))
#+end_src

**** Experiment with Rougier's double modeline

#+begin_src emacs-lisp :tangle no
;; -------------------------------------------------------------------
;; A proof of concept for a multi header or mode line
;;
;; Multi line header or mode line is made possible by generating an
;; SVG image made of two small lines of text. It is certainly memory
;; hungry but it seems to be fast enough to display line/column while
;; typing text. It can probably be extended in a number of ways.
;;
;; Feel free to modify it for your own needs.
;; -------------------------------------------------------------------
(require 'svg)

(defun tag (line-1 font-size-1 font-family-1 foreground-1
            line-2 font-size-2 font-family-2 foreground-2
            left)
  (let* ((font-size-1   (or font-size-1 14))
         (char-width-1  (* font-size-1 0.6))
         (char-height-1 (+ font-size-1 0.0))
         (width-1       (* char-width-1 20))
         (height-1      (+ (* char-height-1 2) 1))

         (font-size-2   (or font-size-2 14))
         (char-width-2  (* font-size-2 0.6))
         (char-height-2 (+ font-size-2 0.0))
         (width-2       (* char-width-2 20))
         (height-2      (+ (* char-height-2 2) 1))

         (width         (max width-1 width-2))
         (height        (max height-1 height-2))

         (x1 (if left 0 (- width (* char-width-1 (+ (length line-1) .0)))))
         (x2 (if left 0 (- width (* char-width-2 (+ (length line-2) .0)))))
         (y1 char-height-1)
         (y2 (+ (* char-height-2 2) 1))
         (svg (svg-create width height)))
    (svg-text svg line-1
              :font-family font-family-1
              :font-size font-size-1 :fill foreground-1
              :x x1 :y y1)

    (svg-text svg line-2
              :font-family font-family-2
              :font-size font-size-2 :fill foreground-2
              :x x2 :y y2)
    svg))

(define-key mode-line-major-mode-keymap [header-line]
  (lookup-key mode-line-major-mode-keymap [mode-line]))

(defun mode-line-render (left right)
  (let* ((available-width (- (window-width) (length left))))
    (format (format "%%s %%%ds" available-width) left right)))

(setq header-line-format
     '((:eval
       (mode-line-render
        (format-mode-line
          (propertize (make-string 20 ?\ )
                      'display (svg-image
                        (tag (format-mode-line "%m") 12 "Roboto Mono Light" "#00008b"
                             (format-mode-line "%b") 14 "Roboto Mono"       "black"
                             t) :ascent 100)))
        (format-mode-line
          (propertize (make-string 18 ?\ )
                      'display (svg-image
                        (tag (format-mode-line "GNU Emacs 26.3  ") 12 "Roboto Mono Light" "#00008b"
                             (format-mode-line "%4l:%2c") 12 "Roboto Mono Light" "#999999"
                             nil) :ascent 100)))))))
#+end_src


**** My much better version
#+begin_src emacs-lisp :tangle yes
(defcustom double-modeline-margin-inner-height 60
  "inner"
  :type 'integer)
(defcustom double-modeline-margin-outer-height 10
  "outer"
  :type 'integer)
#+end_src
#+begin_src emacs-lisp :tangle yes
(after! org
        (require 'svg))
(defun make-svg-rectangle (width height-1 bg-1 height-2 bg-2)
  (let* ((svg (svg-create width (+ height-1 height-2))))
    (svg-rectangle svg 0 0 width height-1 :fill-color bg-1)
    (svg-rectangle svg 0 height-1 width height-2 :fill-color bg-2)
    svg))

(defun make-svg-rectangles (width height-1 bg-1 &rest other)
  (let* ((temptt 0)
         (height-temp height-1)
         (svg (svg-create width
                           (+ height-1
                             (dotimes
                                (i (/ (length other) 2) temptt)
                                         (setq temptt
                                               (+
                                          (nth (* i 2) other)
                                          temptt)))))))
    (svg-rectangle svg 0 0 width height-1 :fill-color bg-1)
    (when other
      (dotimes (i (/ (length other) 2))
    (svg-rectangle svg 0
                   (if (eq i 0) height-1
                     (setq-local height-temp
                                 (+ height-temp
                                    (nth (* (- i 2) 2) other))))
                   width
                   (nth (* i 2) other)
                   :fill-color (nth (+ (* i 2) 1) other))))
    svg))

(defun mode-line-compose (height-1 bg-1 height-2 bg-2
                                   header)
  (let* ((fringe-width (car (window-fringes nil)))
         (body-width (window-body-width nil t))
         (margin-width (* (frame-char-width)
                        (+ (car (window-margins))
                          (cdr (window-margins))))))
    (concat
  (format-mode-line
   (propertize " " 'display (svg-image
    (make-svg-rectangle fringe-width height-1
      bg-1 height-2 bg-1))))
  (format-mode-line
   (propertize " " 'display (svg-image
                            (if header
                             (make-svg-rectangle
                              (+ margin-width body-width)
                        height-1 bg-1 height-2 bg-2)
                             (make-svg-rectangle
                              (+ margin-width body-width)
                        height-2 bg-2 height-1 bg-1)))))
  (format-mode-line
   (propertize " " 'display (svg-image
    (make-svg-rectangle fringe-width height-1
      bg-1 height-2 bg-1)))))))

(defvar double-modeline--default-header-format header-line-format
  "Storage for the default `mode-line-format'.
So it can be restored when 'writer-header-line-mode' is disabled.")

(defvar double-modeline--default-modeline-format mode-line-format)

(define-minor-mode double-header-line-mode
  "Adds a bar with the same color as the fringe as the header-line.
Imitates the look of wordprocessors a bit."
  :init-value nil
  :global nil
  (if double-header-line-mode
      (progn
(set-face-attribute 'mode-line nil :box nil)
(set-face-attribute 'header-line nil :box nil)
(set-face-attribute 'mode-line-inactive nil :box nil)
        (setq header-line-format '((:eval (mode-line-compose
                                   double-modeline-margin-outer-height
                                   (face-background 'fringe)
                                   double-modeline-margin-inner-height
                                   (face-background 'default)
                                   t
                                   ))))
        (setq mode-line-format '((:eval (mode-line-compose
                                   double-modeline-margin-outer-height
                                   (face-background 'fringe)
                                   double-modeline-margin-inner-height
                                   (face-background 'default)
                                   nil
                                   )))))
    (setq header-line-format 'double-modeline--default-header-format
          mode-line-format 'double-modeline--default-modeline-format)))

(after! olivetti-mode (setq double-modeline-margin-inner-height  (round (* 0.6 (* (frame-char-width) (car (window-margins)))))))
#+end_src
*** new pages break
#+begin_src emacs-lisp :tangle no

 (defun change-page-break ()
   (interactive)
   (font-lock-add-keywords 'org-mode
    `((,page-delimiter
       ;; variable with the regexp (usually "^\f" or "^^L")
        0
        (prog1 nil
          ;(compose-region (match-beginning 0) (match-end 0) "")
          ;(testtest)
   (put-text-property (match-beginning 0) (match-end 0)
               'display (svg-image (make-svg-rectangles
                                    ;; just to be sure
                                    (* 3 (window-body-width nil t))
                                    30 "red" 40 "yellow" 30 "red"))
          ;(put-text-property (match-beginning 0) (match-end 0) 'display (make-svg-rectangle (window-body-width nil t) 40 (face-background 'fringe) 30 (face-background 'default)))
          )) t))))
#+end_src

#+begin_src emacs-lisp :tangle yes

 (defun change-page-break ()
   (interactive)
   (font-lock-add-keywords 'org-mode
    `((,page-delimiter
       ;; variable with the regexp (usually "^\f" or "^^L")
        0
        (prog1 nil
          ;(compose-region (match-beginning 0) (match-end 0) "")
          ;(testtest)
          ;(put-text-property (match-beginning 0) (match-end 0) 'display (make-svg-rectangle (window-body-width nil t) 40 (face-background 'fringe) 30 (face-background 'default)))
;; don't display ^L
          (make-line-break (* (frame-char-width) (car (window-margins)))
                           (face-background 'default) 40 (face-background 'fringe))) t))))

(defun make-line-break (h1 bg1 h2 bg2)
         (compose-region (match-beginning 0) (match-end 0) "")
          ;; make an overlay (like in hl-line)
          (let ((pdl (make-overlay (line-beginning-position)                                   (line-beginning-position 2))))
            (overlay-put pdl 'put-image t)
            ;(overlay-put pdl 'after-string
            ;             (propertize "x"
            ;                         'display (list (list 'margin 'left-margin)
            ;                                        (svg-image (make-svg-rectangles (* (frame-char-width) (car (window-margins))) h1 bg1 h2 bg2 h1 bg1 )))))
            (overlay-put pdl 'before-string
                         (concat
                         (propertize "x"
                                     'display (list (list 'margin 'right-margin)
                                                    (svg-image (make-svg-rectangles (* (frame-char-width) (car (window-margins))) h1 bg1 h2 bg2 h1 bg1))))
                         (propertize "x"
                                     'display (list (list 'margin 'left-margin)
                                                    (svg-image (make-svg-rectangles (* (frame-char-width) (car (window-margins))) h1 bg1 h2 bg2 h1 bg1 ))))))
            (overlay-put pdl 'map image-map)
            (overlay-put pdl  'display (svg-image (make-svg-rectangles (- (window-body-width nil t) 0 ) h1 bg1 h2 bg2 h1 bg1)))
            (overlay-put pdl 'modification-hooks
                         ;; these arguments are received from modification-hooks
                         '((lambda (overlay after-p begin end &optional length)
                             (delete-overlay overlay))))
               (overlay-put pdl 'insert-in-front-hooks                         '((lambda (overlay after-p begin end &optional length)
                            (delete-overlay overlay))))))


#+end_src
This should go somewhere else
#+begin_src emacs-lisp :tangle yes
(after! org (change-page-break))
#+end_src
#+begin_src emacs-lisp :tangle no
(defun testtest ()
  (interactive)
  (aayyy 30 (face-background 'default) 40 (face-background 'fringe)))

(defun aayyy (h1 bg1 h2 bg2)
  (progn
   ;(concat
   ;(propertize " "
   ;'display '((margin left-margin) "a"))
   ;(propertize " "
    ;           'display '((margin right-margin) "b"))
   (insert-image (svg-image (make-svg-rectangles (* (frame-char-width) (car (window-margins))) h1 bg1 h2 bg2 h1 bg1)) nil 'left-margin)
   (insert-image (svg-image (make-svg-rectangles (* (frame-char-width) (cdr (window-margins))) h1 bg1 h2 bg2 h1 bg1)) nil 'right-margin)
   (insert (propertize " "
               'display (svg-image (make-svg-rectangles (window-body-width nil t) h1 bg1 h2 bg2 h1 bg1))))
        ))
#+end_src

**** Pseudocode to get what i want

This basically sets up the structure for how I want the minor-mode to work. It's not very complicated and there are probably a lot of edge cases, but its rather close to what I want ti

#+begin_src emacs-lisp :tangle no
(defun change-lines-hook ()
  (unless (check-if-we-need-to-change-anything)
  (disable-all-my-overlays)
  (put-overlays)))

;;either
(add-hook! 'after-save-hook 'change-lines-hook)

;;or, much too expensive probably.
(add-hook! 'after-change-functions 'change-lines-hook)
;mwah maybe okay, org-num-verify also does this and it's somewhat complicated. Really depends on how hard it is to change things.

(defun check-if-no-annoying-env ()
;; some regex which determines where we are in basically anything that's not a paragraph, such as a heading, a latex environment, a link , a table, or a src block
;; There's probably a function that already does this
;; This is not super important for environtments since the overlay won't be part of the text, but it do be kind of annoying
;(org-at-table-p)
;(org-at-property-p)
;(org-at-property-drawer-p)
;(org-at-property-block-p)
;(org-at-block-p)
;(org-at-heading-p)
;(org-at-heading-or-item-p)
;(org-at-planning-p)

        ;check whether we are in a paragraph and not a latex section
(and (eq (car  (org--paragraph-at-point) 'headline))
    (not (latex))))

(define-minor-mode auto-page-break-overlay-mode nil
  "Adds out page breaks, neat."
  :global nil
  :group wysiwyg
  (if auto-page-break-overlay-mode
      (setq some-defaults-i-need-to-rememeber)
      (progn
        (run-once)
        (add-hooks)
        ;change-lines
        )
      (progn    ;else
        (remove-my-overlays)
        (remove-hooks)
        ;change-lines
        (setq-default some-defaults-i-need-to-remember)
        ))
        )



#+end_src

Big problem with visual line approach is that you cannot scale past a certain point, only until the margins run out, when it suddenly scaling becomes bigger font size.
I need to make this work with olivetti mode better, or if necessary implement it myself. Don't really want to do that though, would rather rely on olivetti mode.
 #+begin_src emacs-lisp :tangle no
;; custom pagebreakinterval
(defcustom pagebreakinterval 40)

;; getting visual line number pos
(defun get-visual-line-number-pos (number)
  ...
        )
;; putting the overlay there
(defun put-overlays ()
(dotimes (i (/ (count-screen-lines) pagebreakinterval))
  (make-overlay (visual-line-number (* pagebreakinterval i)) ;start
                (same)                                       ;end
                'display (svg-image (rectangle))             ;
                )))

;;
(defun check-if-we-need-to-change-anything ()
  "Check if we need to change anything."
  (dolist (list-of-overlays overlay)
    (if (eq (position overlay) (* pagebreakinterval i)) t
      (add-to-list 'overlays-to-change (overlay . new-pos)))))

;; some way of making sure that stays like it should
 #+end_src
Another way of keeping track of position would be keeping track of the number of charachters and setting, somewhat intelligently, a "characters of a certain size per page".
    - Pros
      + Don't care about changing lines
      + Finding nth carachter is easier
    - Cons
      + Can happen in the middle of a visual line (would be on me to compute that). This makes inserting the page-break even trickier
      + Possibly more computation heavy, but probably not, the other thing is already very heavy

#+begin_src emacs-lisp :tangle no
;;similar as above, only the (check-if-we-need-to-change-anything)
;; and (put-overlays) need to change
(defcustom number-of-charchters-per-page 2500
  "Page is like 500 words, word has 5 characters by default, badabing badoom.")

(defun put-overlays-chars ()
  (dotimes (i (round (/ (char-count) number-of-characters-per-page)))
    (if (check-if-no-annoying-env)
        (make-overlay (* number-of-charachters-per-page i)
                      (same)
                      'display etc)
      (progn   ;else
        (make-overlay (+ (* number-of-charachters-per-page i) (check-closest-distance-to-safety)) ;;maybe do it anyway if it's too far
                      etc
                      )
        )
)))
#+end_src

ANSWER: I should use both! Count characters, but also lines: if there are too many lines, pagebreak, if there are too many characters, page break as well! Maybe just use the lines then anyway.

**** Creating some cohesion between margins, line-numbers and font-size

     One of the big problems i need to solve (or opitons i need to provide) is whether zooming=zooming or zooming=scaling, i.e. does it just change the visual appearance of everything or does it increase the font size?
     I think the best would be if that were two options, and by default it would do it badly like you would expect, and then I provide a new command which keeps everything nice.

     The main problem now is that the margins do not scale at all when zooming. This is probably something mr olivetti can fix, but I should take it into account nonetheless.

**** Remembering pages

    I should just create a list with pages.
Either with line or character positions. I can update this instead of the page immediately, should save some trouble.
    #+begin_src emacs-lisp :tangle no
(setq page-list (0))
    #+end_src

**** Numbering pages

I would like to not only have pages, but give them a page number, you know, for that extra pizzaz.

The way to do this is probably to
 a) keep track of page numbers, see above
 b) give ~make-svg-rectangles~ the possibility of having a page number displayed
 c) give the big assigning function/minor mode the tools to assign it to it
#+begin_src emacs-lisp :tangle no
;; for the svg
(defun make-svg-rectangles h1 bg1 &opt page &rest other
       "yayayya"
       ;;let part
       ..
       ...
       ...
;; actual svg part
      (when page
       (svg-text svg
                 page ; maybe have options for roman numerals at some point
                 :font-size 60 ;idk
                 :x (round (/ (margin-width-pixel) 2))
                 :y (/ h1 2)
                 :text-anchor "middle"
                 :fill-color (foreground-color 'comment)
                 ))

       )
#+end_src



*** Olivetti, my love
I want thing to be in the middle, and  with olivetti mode the fringes become larger so it looks like a word processor, fantastic!



#+begin_src emacs-lisp :tangle yes
(use-package! olivetti
  :after org
  ;:hook (olivetti-mode . double-header-line-mode)
  :config
    (setq olivetti-min-body-width 50
          olivetti-body-width 80
          olivetti-style t ; fantastic new layout
          olivetti-margin-width 12)
    (add-hook! 'olivetti-mode-hook (window-divider-mode -1))
    (add-hook! 'olivetti-mode-hook (set-face-attribute 'window-divider nil :foreground (face-background 'fringe) :background (face-background 'fringe)))
    (add-hook! 'olivetti-mode-hook (set-face-attribute 'vertical-border nil :foreground (face-background 'fringe) :background (face-background 'fringe)))
    )
#+end_src
*** Trying to get overviews
#+begin_src emacs-lisp :tangle yes
(require 'org-inlinetask)
#+end_src

#+begin_src emacs-lisp :tangle yes
;(use-package! org-sidebar
;  :after org
;  :config
  ;(setq org-sidebar-default-fns '(org-sidebar--todo-items))
  ;(add-hook! 'org-sidebar-window-after-display-hook (solaire-mode 1))
;   )
#+end_src
*************** TODO tasktask
*************** END

#+begin_src emacs-lisp :tangle yes
(after! org
  (remove-hook 'org-agenda-finalize-hook '+org-exclude-agenda-buffers-from-workspace-h)
  (remove-hook 'org-agenda-finalize-hook
               '+org-defer-mode-in-agenda-buffers-h))

(defun thomas/org-get-overview ()
  "Open outline and sidebar."
  (progn
    (org-ol-tree)
    (org-sidebar)))
#+end_src


*** STAY FOCUSED
 Pretty cool: focus only the paragraph you're looking at. Don't really use it though.
 #+begin_src emacs-lisp :tangle yes
(use-package! focus
  :after org-roam
  :config
        (add-to-list 'focus-mode-to-thing '(org-mode . paragraph))
  )
;(require 'nano-writer)
 #+end_src
*** My eyes, they don't work so good no more


 Increase the font-size a bit in org-mode

 FIXME: This is not how you do that dipshit
 #+begin_src emacs-lisp :tangle no
(add-hook! 'org-mode-hook (doom/increase-font-size 1))
 #+end_src
** Custom org-mode profiles

I would like org-mode to look and behave differently depending on what kind of note I'm visiting. Sometimes I want to write in an undistracted environment, sometimes I want to take notes and see a lot of things, sometimes I am configuring this thing and other times I'm going through my tasks: there's no real reason for org to look the same for all of these, and in fact that will probably end up more distracting than anything.

I'm not sure what the best way of going about this is, but I'm thinking a minor mode will do.

#+begin_src emacs-lisp :tangle no
(define-minor-mode org-profile-mode
  "Sets a profile of hooks and minor-modes depending on the file-name."
  :init-value nil
  :global t
(when org-profile-mode
  (when (eq major-mode 'org-mode)
    (cond
      ((string-match-p "[0-9]\\{14\\}" buffer-file-name)
       (message "Note buffer"))
      ((string-match-p "config.org" buffer-file-name)
       (message "Config buffer"))
      ((string-match-p "chapter" buffer-file-name)
       (message "chapter buffer"))
      ((org-agenda-file-p buffer-file-name)
       (message "org-agenda buffer")
        ))
  )))
#+end_src

Something like: if file name contains YYYYMMDD-whatever.org, notes profile.
If file name is in org-agedenda, GTD profile.
Else, writing? No, would be better to have writing be a separate tag/file name thing.

You should be able to indefinitely add profiles. This could be a big list, but that would get kind of hard and I don't know how those work.

For now I can just hard code it, it's fine.


** Custom Minor Modes

   Guaranteed not stolen.
Thank you Prot
#+begin_src emacs-lisp :tangle yes
;;;;;


;;
;;    Custom Minor Modes
;;
;;;;;

(define-minor-mode prot/scroll-center-cursor-mode
  "Toggle centred cursor scrolling behavior"
  :init-value nil
  :lighter " S="
  :global nil
  (if prot/scroll-center-cursor-mode
      (setq-local scroll-margin (* (frame-height) 2)
                  scroll-conservatively 0
                  maximum-scroll-margin 0.5)
    (dolist (local '(scroll-preserve-screen-position
                     scroll-conservatively
                     maximum-scroll-margin
                     scroll-margin))
      (kill-local-variable `,local)))
  )


#+end_src


Make everything variable pitch, who the hell likes reading fixed-pitch?

#+begin_src emacs-lisp :tangle yes
(define-minor-mode prot/variable-pitch-mode
  "Toggle 'mixed-pitch-modei, except for programming modes"
  :init-value nil
  :global nil
  (if prot/variable-pitch-mode
      (unless (derived-mode-p 'prog-mode)
        (variable-pitch-mode 1))
    (variable-pitch-mode -1)))
#+end_src

NO line numbers.

#+begin_src emacs-lisp :tangle yes

(define-minor-mode prot/display-line-number-mode
  "Disable line numbers, except for programming modes."
  :init-value nil
  :global nil
  (if prot/display-line-number-mode
      (unless (derived-mode-p 'prog-mode)
        (display-line-numbers-mode -1))
    (display-line-numbers-mode 1)))
#+end_src

Throw everything together, but in a bad way.
I don't use this anymore, but it did work, except for nano's writing mode, which was very hacky.
#+begin_src emacs-lisp :tangle no
(define-minor-mode thomas/writing-mode
  "Toggle mixed-pitch-mode, center-text, scroll-center and disable line numbers, in writing modes."
  :init-value nil
  :global nil
  (if thomas/writing-mode
      (unless (derived-mode-p 'prog-mode)
        (nano/writer-mode 1)
        (prot/display-line-number-mode 1)
        (prot/variable-pitch-mode 1)
        (prot/scroll-center-cursor-mode 1)
        (olivetti-mode 1)
        (focus-mode 1)
        (org-fragtog-mode 1)
        (org-roam-buffer-deactivate)
        (hl-line-mode -1)
        (org-indent-mode -1)
        (minimap-mode)
        ;(centaur-tabs-mode -1)
        ;(org-mode-restart)
        )
        (prot/display-line-number-mode -1)
        (prot/variable-pitch-mode -1)
        (prot/scroll-center-cursor-mode -1)
        (nano/writer-mode -1)
        (olivetti-mode -1)
        (focus-mode -1)
        (org-fragtog-mode -1)
        ;(centaur-tabs-mode 1 )
        (org-indent-mode 1)
        (minimap-mode -1)
        ;;(org-mode-restart)

        ))

(defun thomas/writing-mode-fun ()
  "Toggle mixed-pitch-mode, center-text, scroll-center and disable line numbers, in writing modes."
  ;;(interactive)
  (org-superstar-mode -1)
  (require 'nano-writer)
  (writer-mode)
        (prot/display-line-number-mode 1)
        (prot/mixed-pitch-mode 1)
        (prot/scroll-center-cursor-mode 1)
        (olivetti-mode 1)
  )


#+end_src

*** Nano writer mode implementation, not used atm

  #+begin_src elisp :tangle no
(defun writer-mode--num-format (numbering)
  "Alternative numbering format for org-num.
First level: 1 | xxx
Second level: 1.1 â€” xxx
Third level: 1.1.1 - xxx
etc."
  (if (= (length numbering) 1)
      (propertize (concat (mapconcat
                           #'number-to-string
                           numbering ".") " | " )
                  'face `(:family "Roboto Condensed"
                          :height 250
                          :foreground ,nano-color-faded))
    (propertize (concat (mapconcat
                         #'number-to-string
                         numbering ".") " â€” " )
                'face `(:family "Roboto Condensed"
                        :foreground ,nano-color-faded))))

;; Specific face for headline stars
;(font-lock-add-keywords 'writer-mode
;             '(("^*+ " 0 `(:family "Roboto Mono"
;                           :height 140
;                           :foreground ,nano-color-faded) prepend)
;               ) 'append)

(defun writer-mode--compute-prefixes ()
  "Compute prefix strings for regular text and headlines."

  (setq org-indent--heading-line-prefixes
        (make-vector org-indent--deepest-level nil))
  (setq org-indent--inlinetask-line-prefixes
        (make-vector org-indent--deepest-level nil))
  (setq org-indent--text-line-prefixes
        (make-vector org-indent--deepest-level nil))

  (let* ((min-indent 5)
         (indent (+ 1 (seq-max
                  (org-element-map
                      (org-element-parse-buffer) 'headline
                    #'(lambda (item)
                        (org-element-property :level item))))))
         (indent (max indent min-indent)))

  (dotimes (n org-indent--deepest-level)
    (aset org-indent--heading-line-prefixes n
          (make-string
           (min indent (max 0 (- indent 1 n))) ?\s))
    (aset org-indent--inlinetask-line-prefixes n
          (make-string indent ?\s))
    (aset org-indent--text-line-prefixes n
          (make-string indent ?\s)))))



(define-minor-mode nano/writer-mode
  "Minor mode which makes writing a lot nicer by moving all the headllines to the left."
  :init-value nil
  :global nil
  ;; Faces
  (face-remap-add-relative 'org-level-1
                           :height 180)
  (face-remap-add-relative 'org-level-2
                            :height 160)
  (face-remap-add-relative 'org-level-3
                            :height 150)
  (face-remap-add-relative 'org-document-info
                           :inherit 'nano-face-faded)
  (face-remap-add-relative 'org-document-title
                           :foreground (face-foreground 'default)
                           :family "Roboto Slab"
                           :height 200
                           :weight 'medium)
  ;; hide title / author ... keywords
  (setq-local org-hidden-keywords '(title author date startup))

  ;; Header line
  (setq header-line-format nil)

  ;; Layout
  (setq fill-column 72)
  (setq-default line-spacing 1)

  ;; Indentation
  (setq org-startup-folded nil)
  (org-indent-mode)
  (setq org-level-color-stars-only nil)
  (setq org-hide-leading-stars nil)
  (advice-add 'org-indent--compute-prefixes :override
              #'writer-mode--compute-prefixes)

  ;; Numbering
  (setq org-num-skip-unnumbered t)
  (setq org-num-skip-footnotes t)
  (setq org-num-max-level 3)
  (setq org-num-face nil)
  (org-num-mode)
  (setq org-num-format-function 'writer-mode--num-format))

;; Fringe shit
;;

  #+end_src

*** Trying to make olivetti-mode better, and failing
 #+begin_src emacs-lisp :tangle no
(setq solaire-mode-remap-fringe nil)
;(set-face-background 'solaire-fringe-face (face-background 'solaire-hl-line-face))


(setq thomas-fringe-size 500)
(setq thomas-margin-size 10)
;  "Variable which sets the size of the fringes."
;  :type 'integer
;  :group 'thomas-aesthetics)

(after! solaire-mode
  (define-minor-mode thomas-fringe-mode
  "Minor mode to hide the mode-line in the current buffer."
  :init-value nil
  :group 'thomas-aesthetics
  (if (not thomas-fringe-mode)
      (progn
        (set-face-background 'solaire-fringe-face (face-background 'solaire-default-face))
        (setq left-fringe-width nil
              right-fringe-width nil))
    (progn (set-face-background 'solaire-fringe-face (face-background 'solaire-hl-line-face))
      (setq left-fringe-width thomas-fringe-size
            right-fringe-width thomas-fringe-size
            left-margin-width thomas-margin-size
            right-margin-width thomas-margin-size)))))

;(add-hook! 'org-mode-hook #'thomas-fringe-mode)
(add-hook! thomas-fringe-mode-hook (custom-set-faces! '(solaire-fringe-face :background (face-background))))
;(setq solaire-mode-remap-fringe nil)


 #+end_src

** Org-latex export

Why does it not simply do what I intend?
#+begin_src emacs-lisp :tangle yes
                ;;;;;;;;
;;
;; org-latex-export
;;
;;;;;;;;

(after! org
   (add-to-list 'org-latex-classes
                '("tufte"
                  "\\documentclass{tufte-book}"
                  ("\\part{%s}" . "\\part*{%s}")
                  ("\\chapter{%s}" . "\\chapter*{%s}")
                  ("\\section{%s}" . "\\section*{%s}")
                  ("\\subsection{%s}" . "\\subsection*{%s}")
                  ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
   (add-to-list 'org-latex-classes
                '("memoir"
                  "\\documentclass{memoir}"
                  ("\\part{%s}" . "\\part*{%s}")
                  ("\\chapter{%s}" . "\\chapter*{%s}")
                  ("\\section{%s}" . "\\section*{%s}")
                  ("\\subsection{%s}" . "\\subsection*{%s}")
                  ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
                )
    (setq org-latex-text-markup-alist '((bold . "\\textbf{%s}")
                                        (code . protectedtexttt)
                                        (italic . "\\emph{%s}")
                                        (strike-through . "\\sout{%s}")
                                        (underline . "\\uline{%s}")
                                        (verbatim . "{\\color{red}%s}")))
(setq org-latex-default-packages-alist
      '(
 ;("AUTO" "inputenc" t
 ; ("pdflatex"))
 ;("T1" "fontenc" t
 ; ("pdflatex"))
 ("utf8" "inputenc" nil)
 ("" "graphicx" t)
 ("" "grffile" t)
 ("" "longtable" nil)
 ("" "wrapfig" nil)
 ("" "rotating" nil)
 ("normalem" "ulem" t)
 ("" "amsmath" t)
 ("" "textcomp" t)
 ("" "amssymb" t)
 ("" "capt-of" nil)
 ("style=apa, backend=biber" "biblatex" nil)
 ("" "braket" nil)
 ("" "xcolor" nil)
 ("" "hyperref" nil))
)
(setq  org-latex-pdf-process
       '("latexmk -shell-escape -bibtex -pdf %f -f")
       org-latex-compiler "xelatex"
       org-latex-bib-compiler "biber")
    )
    ;(add-to-list 'org-latex-default-packages-alist
    ;             '("" "xcolor" nil))
    ;(add-to-list 'org-latex-default-packages-alist
    ;             '("" "braket" nil))
    ;(add-to-list 'org-latex-default-packages-alist '("style=apa, backend=biber" "biblatex" nil)))
    ;(setq org-format-latex-header (concat org-format-latex-header "\n\\")))


#+end_src



* Some other things, such as vterm
** Mail

#+begin_src emacs-lisp :tangle no
(require 'nano-mu4e)
(require 'nano-agenda)
#+end_src

Misc
#+begin_src elisp :tangle yes
        ;;;;;;;;;;;;;
;;;
;;; Other
;;;
;;;;;;;;;;;;

(setq vterm-shell "/usr/bin/fish")

(setq evil-escape-key-sequence "qd")

#+end_src

I would like to use tree-sitter instead of font-lock, but it does not really work well with .tsx and org-mode, so for now it will remain here.
#+begin_src emacs-lisp :tangle yes

;(use-package! tree-sitter
;  :config
;  (require 'tree-sitter-langs)
;  (global-tree-sitter-mode)
;  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))


;(use-package tree-sitter-langs
;  :ensure t
;  :after tree-sitter
;  :config
; (tree-sitter-require 'tsx)
;(add-to-list 'tree-sitter-major-mode-language-alist '(typescript-tsx-mode . tsx)))
#+end_src

Colors in the info box, jeej.
#+begin_src emacs-lisp :tangle yes
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)

#+end_src

* Keyboard shortcuts

** Great keybindings by moi

I just map everything to SPC-r because doom is not using it and r stands for roam.
#+begin_src elisp :tangle yes
(map! :leader
      (:prefix ("r" . "roam")
       :desc "find file"            "f"   #'org-roam-find-file
       :desc "highlight"            "r"   #'org-noter-insert-note
       :desc "center scroll"        "s"   #'prot/scroll-center-cursor-mode
       :desc "start taking notes"   "S"   #'org-noter
       :desc "toggle buffer"        "b"   #'org-roam-buffer-toggle-display
       :desc "insert note"          "i"   #'org-roam-insert
       :desc "server"               "g"   #'org-roam-server
       :desc "quit notes"           "q"   #'org-noter-kill-session
       :desc "tag (roam)"           "t"   #'org-roam-tag-add
       :desc "tag (org)"            "T"   #'org-set-tags-command
       :desc "pomodoro"             "p"   #'org-pomodoro
       :desc "change nano-theme"    "n"   #'nano-toggle-theme
       :desc "rebuid db"            "d"   #'org-roam-db-build-cache
       :desc "cite"                 "c"   #'helm-bibtex
       :desc "thesaurus this word"  "w"  #'powerthesaurus-lookup-word-at-point
       :desc "thesaurus lookup word" "W"   #'powerthesaurus-lookup-word
       :desc "outline"              "o"   #'org-ol-tree
       (:prefix ("m" . "transclusion")
                :desc "make link"            "m"   #'org-transclusion-make-from-link
                :desc "transclusion mode"    "t"   #'org-transclusion-mode
                :desc "add at point"         "a"   #'org-transclusion-add-at-point
                :desc "add all in buffer"    "A"   #'org-transclusion-add-all-in-buffer
                :desc "remove at point"      "r"   #'org-transclusion-remove-at-point
                :desc "remove all in buffer" "R"   #'org-transclusion-remove-all-in-buffer
                :desc "start live edit"      "s"   #'org-transclusion-live-sync-start-at-point
                :desc "stop live edit"       "S"   #'org-transclusion-live-sync-exit-at-point)
       )
      (:prefix ("d" . "GTD")
       :desc  "process inbox" "p"#'org-gtd-process-inbox
       :desc  "agenda list" "a"#'org-agenda-list
       :desc  "capture" "c"#'org-gtd-capture
       :desc  "show next" "n" #'org-gtd-show-all-next
       :desc  "show stuck project" "s" #'org-gtd-show-stuck-projects)
      )
#+end_src

** Workman

   I use the Workman keyboard layout, this package sets most of the evil shortcuts to more sensible positions. I still need to add some more specific shortcuts, for instance for moving windows.
#+begin_src emacs-lisp :tangle yes
(evil-workman-global-mode t)
 #+end_src

This does not fix the window bindings, so we have to do that manually

#+begin_src emacs-lisp :tangle yes
(map!
 :map evil-window-map
      "y" #'evil-window-left
      "Y" #'+evil/window-move-left
      "n" #'evil-window-down
      "N" #'+evil/window-move-down
      "e" #'evil-window-up
      "E" #'+evil/window-move-up
      "o" #'evil-window-right
      "O" #'+evil/window-move-right)
#+end_src


This does not apply them to org-mode, which uses evil-org.el, but those are easily customized

#+begin_src emacs-lisp :tangle yes
(add-hook! 'org-mode-hook #'set-evil-keybindings)

(defun set-evil-keybindings ()
  (progn
  (iscroll-mode 1)
  (setq evil-org-movement-bindings
        '((up . "e")
          (down . "n")
          (left . "y")
          (right . "o")))
  (evil-define-key 'normal evil-org-mode-map
    "o"         'evil-forward-char
    "l"          'evil-org-open-below
    "L"         'evil-org-open-above
    "gy"        'org-backward-element
    "gn"        'org-down-element
    "ge"        'org-up-element
    "go"        'org-forward-element
;    "n"         'evil-next-visual-line
;    "e"         'evil-previous-visual-line
    "n"         'iscroll-forward-line
    "e"         'iscroll-previous-line
    "N"         'evil-next-line
    "E"         'evil-previous-line
    (kbd "C-n") 'follow-scroll-up
    (kbd "C-e") 'follow-scroll-down
    "zn"        '+org-tree-to-indirect-other-window
    "zs"        '+org-tree-to-indirect-current-window
    "zv"        '+org-tree-to-indirect-other-frame
  )
  (when (eq iscroll-mode t)
      (evil-define-key 'normal evil-org-mode-map
        "n" 'iscroll-forward-line
        "e" 'iscroll-previous-line))))
          #+end_src
#+begin_src emacs-lisp :tangle no
(add-hook! 'org-mode-hook #'iscroll-mode)

#+end_src
* Custom functions I keep using

** Get margin width in pixel
#+begin_src emacs-lisp :tangle yes
(defun margin-width-pixel (&optional right)
  "Return the width of the left or optionally right margin in pixels."
  (if (window-margins)
     (if right
           (* (frame-char-width) (cdr (window-margins))) ;;right margin
          (* (frame-char-width) (car (window-margins)))
          0)))
#+end_src
** Refresh org-latex
#+begin_src emacs-lisp :tangle yes
(defun org-latex-refresh ()
  (interactive)
  (progn
  (org-clear-latex-preview)
  (org--latex-preview-region (buffer-end -1) (buffer-end 1))))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun org-latex-clear-preview ()
  (interactive)
  (org-clear-latex-preview))
#+end_src
* To configure

** Some packages to check out

   Binder
   Org-marginalia
   ...

** Tweaks I want to make
   Make olivetti mode margins  scale with the text size better

   Smaller headings, they are a bit ridiculous.
   Zoom in a bit by default.

** TODO Set org env based on title

   I want some way to have emacs recognize settings based on either the title of the org file or its tags. The way I set things up is not conducive for every situation.
*** GTD

    Not sure yet.
*** Config

    Colorful theme so you can see the parentheses well.
    No flyspell etc.

*** Notes

    Less extreme distraction freeness, possibility to open multiple notes
    Sans serif
    Nroam/org-roam-buffer
    Little EAF window with the map
    Treemacs?

*** Writing

    Distraction free layout with olivetti
    Org num
    Marginalia
    Serif
